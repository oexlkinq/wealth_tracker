// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db_api

import (
	"context"
	"time"
)

const createRTractToTract = `-- name: CreateRTractToTract :exec
insert into rtracts_to_tracts (
    rtract_id, tract_id
) values (
    ?, ?
)
`

type CreateRTractToTractParams struct {
	RtractID int64
	TractID  int64
}

func (q *Queries) CreateRTractToTract(ctx context.Context, arg CreateRTractToTractParams) error {
	_, err := q.db.ExecContext(ctx, createRTractToTract, arg.RtractID, arg.TractID)
	return err
}

const getLatestBalanceRecord = `-- name: GetLatestBalanceRecord :one
select br.id, br.amount, br.date, br.origin_tract
from balance_records br
order by br.date desc, br.amount asc
limit 1
`

func (q *Queries) GetLatestBalanceRecord(ctx context.Context) (BalanceRecord, error) {
	row := q.db.QueryRowContext(ctx, getLatestBalanceRecord)
	var i BalanceRecord
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.Date,
		&i.OriginTract,
	)
	return i, err
}

const listTargetsForCalc = `-- name: ListTargetsForCalc :many
select t.id, t.amount, t."desc", t."order", t.tract_id
from targets t
order by t."order" asc
`

func (q *Queries) ListTargetsForCalc(ctx context.Context) ([]Target, error) {
	rows, err := q.db.QueryContext(ctx, listTargetsForCalc)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Target
	for rows.Next() {
		var i Target
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.Desc,
			&i.Order,
			&i.TractID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTractsSince = `-- name: ListTractsSince :many
select t.id, t.type, t.date, t.amount, t.acked
from tracts t
left join rtracts_to_tracts rtt on rtt.tract_id = t.id
where t.date >= ?1 and rtt.rtract_id = ?2
order by date asc
`

type ListTractsSinceParams struct {
	Since    time.Time
	RtractID int64
}

func (q *Queries) ListTractsSince(ctx context.Context, arg ListTractsSinceParams) ([]Tract, error) {
	rows, err := q.db.QueryContext(ctx, listTractsSince, arg.Since, arg.RtractID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tract
	for rows.Next() {
		var i Tract
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Date,
			&i.Amount,
			&i.Acked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnreachedTargets = `-- name: ListUnreachedTargets :many
select t.id, t.amount, t."desc", t."order", t.tract_id
from targets t
where tract_id is null
`

func (q *Queries) ListUnreachedTargets(ctx context.Context) ([]Target, error) {
	rows, err := q.db.QueryContext(ctx, listUnreachedTargets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Target
	for rows.Next() {
		var i Target
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.Desc,
			&i.Order,
			&i.TractID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
