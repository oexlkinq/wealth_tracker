// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db_api

import (
	"context"
	"database/sql"
	"time"
)

const createRTractToTract = `-- name: CreateRTractToTract :exec
insert into rtracts_to_tracts (
    rtract_id, tract_id
) values (
    ?, ?
)
`

type CreateRTractToTractParams struct {
	RtractID int64
	TractID  int64
}

func (q *Queries) CreateRTractToTract(ctx context.Context, arg CreateRTractToTractParams) error {
	_, err := q.db.ExecContext(ctx, createRTractToTract, arg.RtractID, arg.TractID)
	return err
}

const createTract = `-- name: CreateTract :one
insert into tracts (
    type, date, amount, acked
) values (
    ?, ?, ?, ?
)
returning id
`

type CreateTractParams struct {
	Type   string
	Date   time.Time
	Amount float64
	Acked  bool
}

func (q *Queries) CreateTract(ctx context.Context, arg CreateTractParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createTract,
		arg.Type,
		arg.Date,
		arg.Amount,
		arg.Acked,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getLatestBalanceRecord = `-- name: GetLatestBalanceRecord :one
select br.id, br.amount, br.date, br.origin_tract
from balance_records br
order by br.date desc, br.amount asc
limit 1
`

func (q *Queries) GetLatestBalanceRecord(ctx context.Context) (BalanceRecord, error) {
	row := q.db.QueryRowContext(ctx, getLatestBalanceRecord)
	var i BalanceRecord
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.Date,
		&i.OriginTract,
	)
	return i, err
}

const listTargetsForCalc = `-- name: ListTargetsForCalc :many
with RankedTargets as (
    select
        t.id, t.amount, t."desc", t."order", t.tract_id,
        ROW_NUMBER() over (PARTITION BY "order" ORDER BY t.amount DESC) as rn
    from targets t
)
select id, amount, "desc", "order", tract_id, rn
from RankedTargets
where rn = 1
`

type ListTargetsForCalcRow struct {
	ID      int64
	Amount  float64
	Desc    string
	Order   int64
	TractID sql.NullInt64
	Rn      interface{}
}

func (q *Queries) ListTargetsForCalc(ctx context.Context) ([]ListTargetsForCalcRow, error) {
	rows, err := q.db.QueryContext(ctx, listTargetsForCalc)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTargetsForCalcRow
	for rows.Next() {
		var i ListTargetsForCalcRow
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.Desc,
			&i.Order,
			&i.TractID,
			&i.Rn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTractsSince = `-- name: ListTractsSince :many
select t.id, t.type, t.date, t.amount, t.acked
from tracts t
left join rtracts_to_tracts rtt on rtt.tract_id = t.id
where t.date >= ?1 and rtt.rtract_id = ?2
order by date asc
`

type ListTractsSinceParams struct {
	Since    time.Time
	RtractID int64
}

func (q *Queries) ListTractsSince(ctx context.Context, arg ListTractsSinceParams) ([]Tract, error) {
	rows, err := q.db.QueryContext(ctx, listTractsSince, arg.Since, arg.RtractID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tract
	for rows.Next() {
		var i Tract
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Date,
			&i.Amount,
			&i.Acked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnreachedTargets = `-- name: ListUnreachedTargets :many
select t.id, t.amount, t."desc", t."order", t.tract_id
from targets t
where tract_id is null
`

func (q *Queries) ListUnreachedTargets(ctx context.Context) ([]Target, error) {
	rows, err := q.db.QueryContext(ctx, listUnreachedTargets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Target
	for rows.Next() {
		var i Target
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.Desc,
			&i.Order,
			&i.TractID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
