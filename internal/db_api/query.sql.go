// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db_api

import (
	"context"
	"database/sql"
	"time"
)

const createBalanceRecord = `-- name: CreateBalanceRecord :exec
insert into balance_records (
    amount, date, origin_tract
) values (
    ?, ?, ?
)
`

type CreateBalanceRecordParams struct {
	Amount      float64
	Date        time.Time
	OriginTract sql.NullInt64
}

func (q *Queries) CreateBalanceRecord(ctx context.Context, arg CreateBalanceRecordParams) error {
	_, err := q.db.ExecContext(ctx, createBalanceRecord, arg.Amount, arg.Date, arg.OriginTract)
	return err
}

const createRTractToTract = `-- name: CreateRTractToTract :exec
insert into rtracts_to_tracts (
    rtract_id, tract_id
) values (
    ?, ?
)
`

type CreateRTractToTractParams struct {
	RtractID int64
	TractID  int64
}

func (q *Queries) CreateRTractToTract(ctx context.Context, arg CreateRTractToTractParams) error {
	_, err := q.db.ExecContext(ctx, createRTractToTract, arg.RtractID, arg.TractID)
	return err
}

const createTract = `-- name: CreateTract :one
insert into tracts (
    type, date, amount, acked
) values (
    ?, ?, ?, ?
)
returning id
`

type CreateTractParams struct {
	Type   string
	Date   time.Time
	Amount float64
	Acked  bool
}

func (q *Queries) CreateTract(ctx context.Context, arg CreateTractParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createTract,
		arg.Type,
		arg.Date,
		arg.Amount,
		arg.Acked,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteBalanceRecordsSince = `-- name: DeleteBalanceRecordsSince :exec
delete from balance_records
where date >= ?1
`

func (q *Queries) DeleteBalanceRecordsSince(ctx context.Context, since time.Time) error {
	_, err := q.db.ExecContext(ctx, deleteBalanceRecordsSince, since)
	return err
}

const listRTracts = `-- name: ListRTracts :many
select rt.id, rt.rrule, rt."desc", rt.amount, rt.reqs_ack
from rtracts rt
`

func (q *Queries) ListRTracts(ctx context.Context) ([]Rtract, error) {
	rows, err := q.db.QueryContext(ctx, listRTracts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Rtract
	for rows.Next() {
		var i Rtract
		if err := rows.Scan(
			&i.ID,
			&i.Rrule,
			&i.Desc,
			&i.Amount,
			&i.ReqsAck,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTractsSince = `-- name: ListTractsSince :many
select t.amount, t.date
from tracts t
left join rtracts_to_tracts rtt on rtt.tract_id = t.id
where t.date >= ?1 and rtt.rtract_id = ?2
order by date asc
`

type ListTractsSinceParams struct {
	Since    time.Time
	RtractID int64
}

type ListTractsSinceRow struct {
	Amount float64
	Date   time.Time
}

func (q *Queries) ListTractsSince(ctx context.Context, arg ListTractsSinceParams) ([]ListTractsSinceRow, error) {
	rows, err := q.db.QueryContext(ctx, listTractsSince, arg.Since, arg.RtractID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTractsSinceRow
	for rows.Next() {
		var i ListTractsSinceRow
		if err := rows.Scan(&i.Amount, &i.Date); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
